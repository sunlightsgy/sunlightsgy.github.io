<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[sunlight's blog]]></title>
  <subtitle><![CDATA[Free Writing]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://sunlightsgy.github.io/"/>
  <updated>2017-04-11T11:45:25.000Z</updated>
  <id>https://sunlightsgy.github.io/</id>
  
  <author>
    <name><![CDATA[sunlightsgy]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[任务导向的多模态字典学习]]></title>
    <link href="https://sunlightsgy.github.io/2017/04/11/Dictionary_Learning/"/>
    <id>https://sunlightsgy.github.io/2017/04/11/Dictionary_Learning/</id>
    <published>2017-04-11T02:42:29.000Z</published>
    <updated>2017-04-11T11:45:25.000Z</updated>
    <content type="html"><![CDATA[<p>阅读论文：《Multimodal Task-Driven Dictionary Learning for Image Classiﬁcation》</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p><strong>字典学习（Dictionary Learning）</strong>中，输入信号被<strong>字典元素（dictionary atom）</strong>的线性组合所表示。字典学习最初是用来解决单一模态的问题，但是最近的研究表明了对于多模态的输入来说，在特征层面上利用联合稀疏表征（joint sparse representation）可以达到很好的效果。这篇文章提出了一个任务导向的，也即有监督的多模态字典学习方法。在这个方法中，多模态字典和他们对应的分类器是被同时学习的。它利用了<strong>联合稀疏约束（joint sparsity constraint）</strong>来增强同构或异构数据中的联系，获得的多模态字典可以产生有识别力的<strong>隐藏特征（latent features）</strong>，可以用于二分类问题以及多分类问题。此外，这篇文章还提出了一个当前方法的扩展，使用一个 <strong>mixed joint and independent sparsity prior 约束</strong>，使得特征层面的融合变得更加灵活。这篇文章以四个应用验证了他们的方法：多模态人脸识别、多视角人脸识别、多视角动作识别和多模态生物识别。结果也证明，相比于非监督的、重构性的字典学习来说，任务导向的、有监督的学习在计算效率上更胜一筹。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="多模态信息融合"><a href="#多模态信息融合" class="headerlink" title="多模态信息融合"></a>多模态信息融合</h3><p>采集多角度的信息，再将它们融合，往往能得到更好的识别效果。融合方法在大方向上可以分为<strong>特征融合（feature fusion）</strong>和<strong>分类器融合（classifier fusion）</strong>。特征融合方法将从不同来源提取的特征融合进单一的一个特征集中，然后用于分类；而分类器融合方法对每个来源的特征集都设计一个分类器，最后的结果由这些分类器单独的结果决策而成。在过去的研究中，分类器融合方法已经得到了很好的研究，但是特征融合研究甚少，主要是因为不同特征集之间有着诸多的不同，难以适配。一个简单的方法是将所有的特征全部放在一起，但是由于训练集有限，会导致<strong>维度灾难（curse of dimensionality）</strong>。即使我们拥有充足的训练数据，这种做法也不能捕捉不同特征源之间的关系，并且可能有很多噪声和冗余。但是有研究表明如果这些问题得到克服，那么特征融合可能大大提高分类表现。</p>
<blockquote>
<p>维度灾难是在数字图像处理中，对于已知样本数目，存在一个特征数目的最大值，当实际使用的特征数目超过这个最大值时，分类器的性能不是得到改善，而是退化。</p>
</blockquote>
<h3 id="稀疏表示分类"><a href="#稀疏表示分类" class="headerlink" title="稀疏表示分类"></a>稀疏表示分类</h3><p><strong>稀疏表示分类（Sparse representation classification）</strong>近年来也引起了研究人员的兴趣。这种方法已经被成功运用到了人脸识别，视频追踪和短时音频识别中。在稀疏表示中，输入信号被<strong>字典元素（dictionary atom）</strong>的线性组合所表示。在这种方法中，我们往往将所有训练数据放在一起，构建一个结构化的<strong>字典（dictionary）</strong>。这个方法也已经被扩展到特征层面的融合——<strong>多任务学习（multi-task learning）</strong>。在不同的稀疏约束中，<strong>联合稀疏约束（joint sparsity constraint）</strong>在多任务学习应用中展现出了良好的效果。这里面潜在的假设是：多模态的输入可以被多模态字典中的一些字典元素或者训练数据所表征，并且，得到的稀疏系数也应该和他们有同样的稀疏模式。但是，这种构建字典的方法有两个限制：1. 随着训练数据的增大，计算量的增加是非常大的；2. 这种构建方法对于各种任务来说并不是最优化的。</p>
<h3 id="字典学习"><a href="#字典学习" class="headerlink" title="字典学习"></a>字典学习</h3><p>近年来，学术界发现<strong>字典学习（Dictionary Learning）</strong>方法可以有效地克服以上字典构建的缺点。学习出的字典常常是更加小巧紧凑的，其字典元素的大小远小于训练数据量。字典学习方法分为两种：监督的和非监督的。非监督学习致力于为重构性的任务找到一个字典使得其误差最小，比如信号降噪或者图像修复。尽管非监督学习在分类问题上也有所表现，但是任务导向的监督学习能够明显取得更好的效果。对于分类任务，利用分类标签来使得字典最小化分类错误，要好于最小化重构误差。给重构误差加上一个权重，与分类错误率做一个 trade-off，对于一些问题来说会得到比较好的效果。但是有监督字典学习通常更难以取得最优化结果。</p>
<h3 id="多模态字典学习"><a href="#多模态字典学习" class="headerlink" title="多模态字典学习"></a>多模态字典学习</h3><p>现有的字典学习的最大缺陷在于只能用在单一数据来源中。在“Learning view-invariant sparse representations for cross-view action recognition”一文中，一系列视角特有的字典和一个通用的字典被学习出来。视角特有的字典发挥了视角层面的特征效果，而通用字典捕捉了不同视角间的共同模式。它利用标注的数据学习视角特有的字典元素，但是它最小化的是重构误差，并且，它也不能用在异构的模态中。还有一系列的工作，也分别有一些不足之处。</p>
<h3 id="文章贡献"><a href="#文章贡献" class="headerlink" title="文章贡献"></a>文章贡献</h3><ul>
<li><strong>对多模态字典学习方法的形式化表达。</strong>这篇文章提出了一个多模态字典学习方法，使用了同构和异构的数据。不同模态的数据不仅在特征层面进行了融合（采用联合稀疏表征），也在决策层面进行了融合（对模态特有的分类器进行得分加权）。该方法同时学习特征和分类器，将隐藏稀疏编码作为最优化的特征，用于分类问题。一个非监督学习的方法作为本方法的副产品也被提了出来。</li>
<li><strong>双层优化问题的可微性。</strong>这个方法的最大难点在于，关于字典数，联合稀疏编码的问题是不可微的。虽然联合稀疏编码有一个不平滑的代价函数，但是从这篇文章的推导可以看出它是局部可微的，这样对应的最优化就是平滑的，可以用随机梯度下降法解出。</li>
<li><strong>灵活的特征融合。</strong>本文一个拓展是提供一个在独立稀疏表示和联合稀疏表示之间的 trade-off。</li>
<li><strong>提升了多模态分类的准确率。</strong></li>
<li><strong>提升了基于稀疏表示的分类效率。</strong></li>
</ul>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="字典学习-1"><a href="#字典学习-1" class="headerlink" title="字典学习"></a>字典学习</h3><p>与 PCA 方法不同，字典学习不需要强制使用正交条件，对于训练数据更加的灵活。令$\mathbf{X}=[x_1,x_2,…,x_N]\in R^{n\times N}​$ 为N个训练样本的集合，字典$D\in R^{n \times d}​$可以通过最小化下列经验代价函数得到</p>
<p> $g<em>N(D)=\frac{1}{N}\sum^N</em>{i=1}l_u(x_i,D)$       (1)</p>
<p>要满足 $D \in R^{n\times d},||d<em>k||</em>{l_2}\leq1$，其中 $d_k$ 是 D 的第 k 个字典元素。非监督的 loss function 定义为</p>
<p>$l_u(x<em>i,D)=min</em>{\alpha\in R^{d}}||x-Da||^2_{l_2}+\lambda<em>1||\alpha||</em>{l_1}+\lambda<em>2||\alpha||^2</em>{l_2}$</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>阅读论文：《Multimodal Task-Driven Dictionary Learning for Image Classiﬁcation》</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a]]>
    </summary>
    
      <category term="machine_learning" scheme="https://sunlightsgy.github.io/tags/machine-learning/"/>
    
      <category term="papers_reading" scheme="https://sunlightsgy.github.io/categories/papers-reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多密钥ssh-key生成与管理]]></title>
    <link href="https://sunlightsgy.github.io/2017/04/06/%E5%A4%9A%E5%AF%86%E9%92%A5ssh-key%E7%94%9F%E6%88%90%E4%B8%8E%E7%AE%A1%E7%90%86/"/>
    <id>https://sunlightsgy.github.io/2017/04/06/多密钥ssh-key生成与管理/</id>
    <published>2017-04-06T14:58:42.000Z</published>
    <updated>2017-04-06T15:46:46.000Z</updated>
    <content type="html"><![CDATA[<p>由于 git 大文件用 http 方式难以传输，必须使用 ssh-key，而 ssh-key 又生成了好多个。最近在各种折腾 ssh，公钥私钥上花费了很多时间，现将一些问题总结如下。系统为 Mac/Linux。</p>
<h2 id="密钥的原理"><a href="#密钥的原理" class="headerlink" title="密钥的原理"></a>密钥的原理</h2><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p>
<a id="more"></a>
<p>整个ssh密码登录过程是这样的：</p>
<ol>
<li>用户向远程主机发登录请求：ssh user@远程主机</li>
<li>远程主机收到用户的登录请求，把自己的公钥发给用户。</li>
<li>用户使用这个公钥，将登录密码加密后，发送回远程主机。</li>
<li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li>
</ol>
<p>在linux上，如果你是第一次登录对方主机，系统会出现下面的提示：</p>
<blockquote>
<p>$ ssh user@host </p>
<p>The authenticity of host ‘host (12.18.429.21)’ can’t be established. </p>
<p>RSA key fingerprint is 98:2e:d7:e0:de9f:ac:67:28:c2:42:2d:37:16:58:4d. </p>
<p>Are you sure you want to continue connecting (yes/no)?</p>
</blockquote>
<p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？ </p>
<p>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是<code>98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d</code>，再进行比较，就容易多了。 </p>
<p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。 </p>
<p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。 </p>
<blockquote>
<p>Are you sure you want to continue connecting (yes/no)? yes</p>
</blockquote>
<p>系统会出现一句提示，表示host主机已经得到认可。 </p>
<blockquote>
<p>Warning: Permanently added ‘host,12.18.429.21’ (RSA) to the list of known hosts.</p>
</blockquote>
<p>然后，会要求输入密码。 </p>
<blockquote>
<p>Password: (enter password)</p>
</blockquote>
<p>如果密码正确，就可以登录了。 </p>
<p>原文：<a href="http://itindex.net/detail/48724-ssh-%E8%AE%A4%E8%AF%81-%E5%8E%9F%E7%90%86?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://itindex.net/detail/48724-ssh-认证-原理</a></p>
<h2 id="密钥的生成和管理"><a href="#密钥的生成和管理" class="headerlink" title="密钥的生成和管理"></a>密钥的生成和管理</h2><h3 id="密钥的生成"><a href="#密钥的生成" class="headerlink" title="密钥的生成"></a>密钥的生成</h3><p>在命令行中，键入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;$your_email&quot;</div></pre></td></tr></table></figure>
<p>会生成一对密钥，默认的情况下，私钥将放在<code>~/.ssh/id_rsa</code>，对应的公钥则为<code>~/.ssh/id_rsa.pub</code>。</p>
<p>在生成的过程中，会询问你放密钥的位置。由于每个人可能不止需要一个密钥，所以可以另存为其他名字的密钥，比如<code>path/to/your/dir/id_rsa_new</code>，此时它也将生成对应的公钥。</p>
<p>使用以下代码来查看生成的公钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>
<p>将公钥复制到你需要的服务器上（比如 github，gitlab 等等）</p>
<h3 id="密钥的管理"><a href="#密钥的管理" class="headerlink" title="密钥的管理"></a>密钥的管理</h3><p>如前文所说，如果我们需要多个密钥，那么在使用中，如何确定实际使用哪一个呢？</p>
<p>目前为止，ssh-key 用得最多的两个 地方，一是 git 相关服务，二是远程连接服务器。</p>
<h4 id="命令输入"><a href="#命令输入" class="headerlink" title="命令输入"></a>命令输入</h4><p>用<code>-i</code>指定私钥，<code>-p</code>指定端口，连接服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh -i path/to/your/key developer@192.168.1.237 -p 23</div><div class="line">scp -i path/to/your/key filename developer@192.168.1.237:/diskpath</div></pre></td></tr></table></figure>
<h4 id="配置-ssh-config-文件"><a href="#配置-ssh-config-文件" class="headerlink" title="配置 ~/.ssh/config 文件"></a>配置 ~/.ssh/config 文件</h4><p>由于 git 命令不能指定私钥，所以要通过 ~/.ssh/config 文件来控制。如果没有就在~/.ssh目录创建config文件，该文件用于配置私钥对应的服务器。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Host github</div><div class="line">HostName github.com</div><div class="line">User git</div><div class="line">IdentityFile ~/.ssh/id_rsa</div><div class="line"> </div><div class="line">Host tsinghua</div><div class="line">HostName tsinghua.edu.cn</div><div class="line">User git</div><div class="line">IdentityFile ~/.ssh/id_rsa_new</div></pre></td></tr></table></figure>
<p>这样，链接到 github.com 时，使用的就是 id_rsa；链接到 tsinghua.edu.cn 时，使用 id_rsa_new。另外，Host 的名字可以随便设置，并且在 ssh 后面相当于 User@HostName，比如 <code>ssh github</code> 等价于 <code>ssh git@github.com</code>。</p>
<h4 id="私钥密码修改"><a href="#私钥密码修改" class="headerlink" title="私钥密码修改"></a>私钥密码修改</h4><p>如果工作中，你使用了一个没有密码的私钥，有一天服务器被黑了，你是跳到黄河都洗不清。而生成密钥时，往往会选择一个比较简单的密码。为了安全起见，还是应该修改一下：利用<code>ssh-keygen -p</code>，系统会提示选择需要修改的私钥，默认是<code>~/.ssh/id_rsa</code>，选好文件后按回车，会提示你输入旧密码，输入好后会提示输入新密码，则修改完成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于 git 大文件用 http 方式难以传输，必须使用 ssh-key，而 ssh-key 又生成了好多个。最近在各种折腾 ssh，公钥私钥上花费了很多时间，现将一些问题总结如下。系统为 Mac/Linux。</p>
<h2 id="密钥的原理"><a href="#密钥的原理" class="headerlink" title="密钥的原理"></a>密钥的原理</h2><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p>]]>
    
    </summary>
    
      <category term="git" scheme="https://sunlightsgy.github.io/tags/git/"/>
    
      <category term="engineering" scheme="https://sunlightsgy.github.io/categories/engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSAPP Buflab 解题报告]]></title>
    <link href="https://sunlightsgy.github.io/2017/03/05/CSAPP-Buflab-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://sunlightsgy.github.io/2017/03/05/CSAPP-Buflab-解题报告/</id>
    <published>2017-03-05T03:01:36.000Z</published>
    <updated>2017-03-05T03:07:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>这次的实验让我们对栈进行更深入的了解，通过读入超出栈帧容量的数据来破坏栈的结构，从而达到我们自己想要的效果。</p>
<p>从实验中可以看出，就前四个level而言，在程序正常运行的情况下我们所能输入的最大字符串长度为0x28，也就是40byte。往上4个byte是寄存器ebp的值，再往上4个byte则是返回地址。第五个实验，最大字符串长度则为520byte。</p>
<a id="more"></a>
<h3 id="Level-0-Candle"><a href="#Level-0-Candle" class="headerlink" title="Level 0: Candle"></a>Level 0: Candle</h3><p>本题只需要我们把返回地址修改到<code>smoke()</code>函数中，因此我们可以填上44个无用字节，然后填上<code>smoke()</code>的地址。我获得的地址为0x08048be8，因此最后4个byte填上 e8 8b 04 08 即可。</p>
<p>###Level 1: Sparkler</p>
<p>本题要我们传入自己的cookie作为参数运行fizz函数。注意到<code>fizz(int)</code>函数中有这么一句<code>mov    0x8(%ebp),%eax</code>，也就是说，在返回值的上8个字节中，需要填入我的cookie，同时返回值应该填<code>fizz(int)</code>的入口。<code>fizz(int)</code>的入口为0x08048c12，而我的cookie为737220a6。因此，分别在两个位置倒序输出即可。</p>
<h3 id="Level-2-Firecracker"><a href="#Level-2-Firecracker" class="headerlink" title="Level 2: Firecracker"></a>Level 2: Firecracker</h3><p>本题要我们在传入<code>bang(int)</code>函数时，以我的cookie修改一个全局变量的值。首先用gdb找到这个全局变量的地址0x0804d100，然后反汇编以下代码：<br>​<br>    movl $0x737220a6, %eax<br>    movl $0x0804d100, %ecx<br>    movl %eax,(%ecx)<br>    ret</p>
<p>将它放在我们填充的字符串的开头。然后用00补齐剩下的字符串，在将返回地址设为<code>%ebp-0x28</code>的地址，这样就可以运行我们的代码了。再将返回地址的上4个byte设为<code>bang(int)</code>的入口地址，即可在二次返回时进入正确的函数。</p>
<h3 id="Level-3-Dynamite"><a href="#Level-3-Dynamite" class="headerlink" title="Level 3: Dynamite"></a>Level 3: Dynamite</h3><p>之前的实验破坏了栈的结构，这个实验要我们恢复它。首先我们还是要改变eax的值，然后要将返回地址设为原来该返回的地方(0x8048d8e)。所以反汇编以下代码：</p>
<pre><code>movl $0x737220a6, %eax
pushl $0x8048d8e
ret
</code></pre><p>这样就能正确地返回入口。但是还需要保持ebp的状态不被改变，因为在填入字符串的时候，ebp的值被覆盖了。所以，覆盖那部分的值，应该是ebp原来所保持的值(0x55683db0)。所以，将以上几个部分修改完就可以了。</p>
<h3 id="Level-4-Nitroglycerin"><a href="#Level-4-Nitroglycerin" class="headerlink" title="Level 4: Nitroglycerin"></a>Level 4: Nitroglycerin</h3><p>本题和上一个题所不同的就是，这里的栈指针是改变的。因此，要获得ebp的值，只能根据上下文的esp的值来操作。可以发现在<code>getbufn()</code>函数中，最终所要保持的ebp值为<code>0x28(%esp)</code>,所以反汇编以下代码。</p>
<pre><code>lea 0x28(%esp), %ebp
movl $0x737220a6, %eax
movl $0x8048e0b, %edx
subl $1,%edx
subl $4,%esp
movl %edx,(%esp)
ret
</code></pre><p>同时，值得注意的是这次需要填的长度为520个字符，并且之前的字符应该都填90(nop)指令，直到能正好存下以上代码。然后原ebp所在的地址可以任意覆盖，返回地址上应该填入多次试验后所获得的栈底的最高位置。如此，便完成了这个第五题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>这次的实验让我们对栈进行更深入的了解，通过读入超出栈帧容量的数据来破坏栈的结构，从而达到我们自己想要的效果。</p>
<p>从实验中可以看出，就前四个level而言，在程序正常运行的情况下我们所能输入的最大字符串长度为0x28，也就是40byte。往上4个byte是寄存器ebp的值，再往上4个byte则是返回地址。第五个实验，最大字符串长度则为520byte。</p>]]>
    
    </summary>
    
      <category term="assembly" scheme="https://sunlightsgy.github.io/tags/assembly/"/>
    
      <category term="courses" scheme="https://sunlightsgy.github.io/categories/courses/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSAPP Bomblab 解题报告]]></title>
    <link href="https://sunlightsgy.github.io/2017/03/05/CSAPP-Bomblab-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://sunlightsgy.github.io/2017/03/05/CSAPP-Bomblab-解题报告/</id>
    <published>2017-03-05T02:17:38.000Z</published>
    <updated>2017-03-05T02:24:21.000Z</updated>
    <content type="html"><![CDATA[<p>这次实验其实就是让我们对课上学习的汇编代码进行熟悉，比如堆栈的使用，函数的传参。一共有六个关卡和一个隐藏关卡，每一个关卡都需要我们进行一行输入，如果输入的数字或者字符串满足一定的要求，就能跳过<code>callq  0x4016a8 &lt;explode_bomb&gt;</code>这一个导致“炸弹爆炸”的调用，进行下一个阶段。当六个阶段解决完毕后，该题目通过。此外还有一个隐藏关，需要显式调用<code>call 0x401323 &lt;secret_phase&gt;</code>来完成。</p>
<a id="more"></a>
<h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><pre><code>0x0000000000400f50 &lt;+0&gt;:    sub    $0x8,%rsp
0x0000000000400f54 &lt;+4&gt;:    mov    $0x402690,%esi
0x0000000000400f59 &lt;+9&gt;:    callq  0x401418 &lt;strings_not_equal&gt;
0x0000000000400f5e &lt;+14&gt;:   test   %eax,%eax
0x0000000000400f60 &lt;+16&gt;:   je     0x400f67 &lt;phase_1+23&gt;
0x0000000000400f62 &lt;+18&gt;:   callq  0x4016a8 &lt;explode_bomb&gt;
0x0000000000400f67 &lt;+23&gt;:   add    $0x8,%rsp
0x0000000000400f6b &lt;+27&gt;:   retq   
</code></pre><p>这一关是拿来练手的，从程序中可以发现，我们需要比较输入字符串和位于内存0x402690处的字符串，如果它们是一样的，那么就能通过。用gdb调试，输入<code>x /s 0x402690</code>，就能看到其中的字符串为”I can see Russia from my house!”。输入后，通过phase_1。</p>
<h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><pre><code>0x0000000000400f6c &lt;+0&gt;:    push   %rbp
0x0000000000400f6d &lt;+1&gt;:    push   %rbx
0x0000000000400f6e &lt;+2&gt;:    sub    $0x28,%rsp
0x0000000000400f72 &lt;+6&gt;:    mov    %rsp,%rsi
0x0000000000400f75 &lt;+9&gt;:    callq  0x4016de &lt;read_six_numbers&gt;
0x0000000000400f7a &lt;+14&gt;:    cmpl   $0x1,(%rsp)
0x0000000000400f7e &lt;+18&gt;:    je     0x400fa0 &lt;phase_2+52&gt;
0x0000000000400f80 &lt;+20&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x0000000000400f85 &lt;+25&gt;:    jmp    0x400fa0 &lt;phase_2+52&gt;
0x0000000000400f87 &lt;+27&gt;:    mov    -0x4(%rbx),%eax
0x0000000000400f8a &lt;+30&gt;:    add    %eax,%eax
0x0000000000400f8c &lt;+32&gt;:    cmp    %eax,(%rbx)
0x0000000000400f8e &lt;+34&gt;:    je     0x400f95 &lt;phase_2+41&gt;
0x0000000000400f90 &lt;+36&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x0000000000400f95 &lt;+41&gt;:    add    $0x4,%rbx
0x0000000000400f99 &lt;+45&gt;:    cmp    %rbp,%rbx
0x0000000000400f9c &lt;+48&gt;:    jne    0x400f87 &lt;phase_2+27&gt;
0x0000000000400f9e &lt;+50&gt;:    jmp    0x400fac &lt;phase_2+64&gt;
0x0000000000400fa0 &lt;+52&gt;:    lea    0x4(%rsp),%rbx
0x0000000000400fa5 &lt;+57&gt;:    lea    0x18(%rsp),%rbp
0x0000000000400faa &lt;+62&gt;:    jmp    0x400f87 &lt;phase_2+27&gt;
0x0000000000400fac &lt;+64&gt;:    add    $0x28,%rsp
0x0000000000400fb0 &lt;+68&gt;:    pop    %rbx
0x0000000000400fb1 &lt;+69&gt;:    pop    %rbp
0x0000000000400fb2 &lt;+70&gt;:    retq  
</code></pre><p>可以看出，第二个程序调用了函数<code>read_six_number</code>，需要我们读入六个数，分别保存在<code>rsp</code>到<code>rsp+0x14</code>中。之后便是循环判断，可以看出是一个等比数列。先判断第一个数是不是等于1，如果是的话进行下一个数的判断，每个数都应该等于<code>%eax+%eax</code>，这里的eax就是上一个数的值。因此，可以知道本题的输入为 1 2 4 8 16 32.</p>
<h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><pre><code>0x0000000000400fb3 &lt;+0&gt;:    sub    $0x18,%rsp
0x0000000000400fb7 &lt;+4&gt;:    lea    0xc(%rsp),%r8
0x0000000000400fbc &lt;+9&gt;:    lea    0x7(%rsp),%rcx
0x0000000000400fc1 &lt;+14&gt;:    lea    0x8(%rsp),%rdx
0x0000000000400fc6 &lt;+19&gt;:    mov    $0x4026d6,%esi
0x0000000000400fcb &lt;+24&gt;:    mov    $0x0,%eax
0x0000000000400fd0 &lt;+29&gt;:    callq  0x400c70 &lt;__isoc99_sscanf@plt&gt;
0x0000000000400fd5 &lt;+34&gt;:    cmp    $0x2,%eax
0x0000000000400fd8 &lt;+37&gt;:    jg     0x400fdf &lt;phase_3+44&gt;
0x0000000000400fda &lt;+39&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x0000000000400fdf &lt;+44&gt;:    cmpl   $0x7,0x8(%rsp)
0x0000000000400fe4 &lt;+49&gt;:    ja     0x4010e6 &lt;phase_3+307&gt;
0x0000000000400fea &lt;+55&gt;:    mov    0x8(%rsp),%eax
0x0000000000400fee &lt;+59&gt;:    jmpq   *0x4026e0(,%rax,8)
0x0000000000400ff5 &lt;+66&gt;:    mov    $0x6f,%eax
0x0000000000400ffa &lt;+71&gt;:    cmpl   $0x89,0xc(%rsp)
0x0000000000401002 &lt;+79&gt;:    je     0x4010f0 &lt;phase_3+317&gt;
0x0000000000401008 &lt;+85&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x000000000040100d &lt;+90&gt;:    mov    $0x6f,%eax
0x0000000000401012 &lt;+95&gt;:    jmpq   0x4010f0 &lt;phase_3+317&gt;
0x0000000000401017 &lt;+100&gt;:    mov    $0x6d,%eax
0x000000000040101c &lt;+105&gt;:    cmpl   $0x1d6,0xc(%rsp)
0x0000000000401024 &lt;+113&gt;:    je     0x4010f0 &lt;phase_3+317&gt;
0x000000000040102a &lt;+119&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x000000000040102f &lt;+124&gt;:    mov    $0x6d,%eax
0x0000000000401034 &lt;+129&gt;:    jmpq   0x4010f0 &lt;phase_3+317&gt;
0x0000000000401039 &lt;+134&gt;:    mov    $0x6e,%eax
0x000000000040103e &lt;+139&gt;:    cmpl   $0x319,0xc(%rsp)
0x0000000000401046 &lt;+147&gt;:    je     0x4010f0 &lt;phase_3+317&gt;
0x000000000040104c &lt;+153&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x0000000000401051 &lt;+158&gt;:    mov    $0x6e,%eax
0x0000000000401056 &lt;+163&gt;:    jmpq   0x4010f0 &lt;phase_3+317&gt;
0x000000000040105b &lt;+168&gt;:    mov    $0x77,%eax
0x0000000000401060 &lt;+173&gt;:    cmpl   $0x3b8,0xc(%rsp)
0x0000000000401068 &lt;+181&gt;:    je     0x4010f0 &lt;phase_3+317&gt;
0x000000000040106e &lt;+187&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x0000000000401073 &lt;+192&gt;:    mov    $0x77,%eax
0x0000000000401078 &lt;+197&gt;:    jmp    0x4010f0 &lt;phase_3+317&gt;
0x000000000040107a &lt;+199&gt;:    mov    $0x71,%eax
0x000000000040107f &lt;+204&gt;:    cmpl   $0x1c6,0xc(%rsp)
0x0000000000401087 &lt;+212&gt;:    je     0x4010f0 &lt;phase_3+317&gt;
0x0000000000401089 &lt;+214&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x000000000040108e &lt;+219&gt;:    mov    $0x71,%eax
0x0000000000401093 &lt;+224&gt;:    jmp    0x4010f0 &lt;phase_3+317&gt;
0x0000000000401095 &lt;+226&gt;:    mov    $0x73,%eax
0x000000000040109a &lt;+231&gt;:    cmpl   $0x26e,0xc(%rsp)
0x00000000004010a2 &lt;+239&gt;:    je     0x4010f0 &lt;phase_3+317&gt;
0x00000000004010a4 &lt;+241&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x00000000004010a9 &lt;+246&gt;:    mov    $0x73,%eax
0x00000000004010ae &lt;+251&gt;:    jmp    0x4010f0 &lt;phase_3+317&gt;
0x00000000004010b0 &lt;+253&gt;:    mov    $0x79,%eax
0x00000000004010b5 &lt;+258&gt;:    cmpl   $0x26f,0xc(%rsp)
0x00000000004010bd &lt;+266&gt;:    je     0x4010f0 &lt;phase_3+317&gt;
0x00000000004010bf &lt;+268&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x00000000004010c4 &lt;+273&gt;:    mov    $0x79,%eax
0x00000000004010c9 &lt;+278&gt;:    jmp    0x4010f0 &lt;phase_3+317&gt;
0x00000000004010cb &lt;+280&gt;:    mov    $0x6e,%eax
0x00000000004010d0 &lt;+285&gt;:    cmpl   $0x96,0xc(%rsp)
0x00000000004010d8 &lt;+293&gt;:    je     0x4010f0 &lt;phase_3+317&gt;
0x00000000004010da &lt;+295&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x00000000004010df &lt;+300&gt;:    mov    $0x6e,%eax
0x00000000004010e4 &lt;+305&gt;:    jmp    0x4010f0 &lt;phase_3+317&gt;
0x00000000004010e6 &lt;+307&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x00000000004010eb &lt;+312&gt;:    mov    $0x67,%eax
0x00000000004010f0 &lt;+317&gt;:    cmp    0x7(%rsp),%al
0x00000000004010f4 &lt;+321&gt;:    je     0x4010fb &lt;phase_3+328&gt;
0x00000000004010f6 &lt;+323&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x00000000004010fb &lt;+328&gt;:    add    $0x18,%rsp
0x00000000004010ff &lt;+332&gt;:    retq
</code></pre><p>这题是一个有多个答案的题目。其输入格式为<code>%d %c %d</code>，即输入两个数字及一个字符。首先第一个输入的无符号格式不能超过7，也就是说，第一个输入可以是0~7中任意一个。而<code>jmpq   *0x4026e0(,%rax,8)</code>这条指令就会根据第一个输入的大小跳转到相应的代码片段。比如说当第一个输入等于0时，就有跳转到0x4026e0所对应的地址。用<code>x /w 0x4026e0</code>查看，发现地址为0x400ff5，再对应代码段，发现此事要让第三个参数等于0x89，也就是十进制137。再跳到317行，发现输入的字母要和eax的末两位相同，当第一个输入为0时，%eax为0x6f，故转化为字符得o。</p>
<p>所以其中一个答案就是0 o 137。</p>
<h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><pre><code>0x000000000040113e &lt;+0&gt;:     sub    $0x18,%rsp
0x0000000000401142 &lt;+4&gt;:     lea    0xc(%rsp),%rcx
0x0000000000401147 &lt;+9&gt;:     lea    0x8(%rsp),%rdx
0x000000000040114c &lt;+14&gt;:    mov    $0x402975,%esi
0x0000000000401151 &lt;+19&gt;:    mov    $0x0,%eax
0x0000000000401156 &lt;+24&gt;:    callq  0x400c70 &lt;__isoc99_sscanf@plt&gt;
0x000000000040115b &lt;+29&gt;:    cmp    $0x2,%eax
0x000000000040115e &lt;+32&gt;:    jne    0x401167 &lt;phase_4+41&gt;
0x0000000000401160 &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)
0x0000000000401165 &lt;+39&gt;:    jbe    0x40116c &lt;phase_4+46&gt;
0x0000000000401167 &lt;+41&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x000000000040116c &lt;+46&gt;:    mov    $0xe,%edx
0x0000000000401171 &lt;+51&gt;:    mov    $0x0,%esi
0x0000000000401176 &lt;+56&gt;:    mov    0x8(%rsp),%edi
0x000000000040117a &lt;+60&gt;:    callq  0x401100 &lt;func4&gt;
0x000000000040117f &lt;+65&gt;:    test   %eax,%eax
0x0000000000401181 &lt;+67&gt;:    jne    0x40118a &lt;phase_4+76&gt;
0x0000000000401183 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)
0x0000000000401188 &lt;+74&gt;:    je     0x40118f &lt;phase_4+81&gt;
0x000000000040118a &lt;+76&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x000000000040118f &lt;+81&gt;:    add    $0x18,%rsp
0x0000000000401193 &lt;+85&gt;:    retq   
</code></pre><p>本题要求输入两个数字，且第一个数字需要小于等于14，然后经过func4函数对eax，esi和edx的值的一系列改变，最终得到调用后的eax要等于0。而第二个参数由于只有一句判断，故只要等于0即可。下面来看func4函数。</p>
<pre><code>0x0000000000401100 &lt;+0&gt;:     sub    $0x8,%rsp
0x0000000000401104 &lt;+4&gt;:     mov    %edx,%eax
0x0000000000401106 &lt;+6&gt;:     sub    %esi,%eax
0x0000000000401108 &lt;+8&gt;:     mov    %eax,%ecx
0x000000000040110a &lt;+10&gt;:    shr    $0x1f,%ecx
0x000000000040110d &lt;+13&gt;:    add    %ecx,%eax
0x000000000040110f &lt;+15&gt;:    sar    %eax
0x0000000000401111 &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx
0x0000000000401114 &lt;+20&gt;:    cmp    %edi,%ecx
0x0000000000401116 &lt;+22&gt;:    jle    0x401124 &lt;func4+36&gt;
0x0000000000401118 &lt;+24&gt;:    lea    -0x1(%rcx),%edx
0x000000000040111b &lt;+27&gt;:    callq  0x401100 &lt;func4&gt;
0x0000000000401120 &lt;+32&gt;:    add    %eax,%eax
0x0000000000401122 &lt;+34&gt;:    jmp    0x401139 &lt;func4+57&gt;
0x0000000000401124 &lt;+36&gt;:    mov    $0x0,%eax
0x0000000000401129 &lt;+41&gt;:    cmp    %edi,%ecx
0x000000000040112b &lt;+43&gt;:    jge    0x401139 &lt;func4+57&gt;
0x000000000040112d &lt;+45&gt;:    lea    0x1(%rcx),%esi
0x0000000000401130 &lt;+48&gt;:    callq  0x401100 &lt;func4&gt;
0x0000000000401135 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax
0x0000000000401139 &lt;+57&gt;:    add    $0x8,%rsp
0x000000000040113d &lt;+61&gt;:    retq   
</code></pre><p>可以看到，如果要让eax输出为0,那么就必须让中间的某一步eax=0。纵观整个函数，需要让<code>jle    0x401124 &lt;func4+36&gt;</code>执行一次将eax清0。这时我们发现，下面又有<code>jge    0x401139 &lt;func4+57&gt;</code>，这意味着必须esi等于0才能进行这一步。esi初始就是我们输入的第一个数。</p>
<p>所以，这题的答案是0 0。</p>
<h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><pre><code>0x0000000000401194 &lt;+0&gt;:    push   %rbx
0x0000000000401195 &lt;+1&gt;:    mov    %rdi,%rbx
0x0000000000401198 &lt;+4&gt;:    callq  0x4013fb &lt;string_length&gt;
0x000000000040119d &lt;+9&gt;:    cmp    $0x6,%eax
0x00000000004011a0 &lt;+12&gt;:    je     0x4011a7 &lt;phase_5+19&gt;
0x00000000004011a2 &lt;+14&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x00000000004011a7 &lt;+19&gt;:    mov    $0x0,%eax
0x00000000004011ac &lt;+24&gt;:    mov    $0x0,%edx
0x00000000004011b1 &lt;+29&gt;:    movzbl (%rbx,%rax,1),%ecx
0x00000000004011b5 &lt;+33&gt;:    and    $0xf,%ecx
0x00000000004011b8 &lt;+36&gt;:    add    0x402720(,%rcx,4),%edx
0x00000000004011bf &lt;+43&gt;:    add    $0x1,%rax
0x00000000004011c3 &lt;+47&gt;:    cmp    $0x6,%rax
0x00000000004011c7 &lt;+51&gt;:    jne    0x4011b1 &lt;phase_5+29&gt;
0x00000000004011c9 &lt;+53&gt;:    cmp    $0x2b,%edx
0x00000000004011cc &lt;+56&gt;:    je     0x4011d3 &lt;phase_5+63&gt;
0x00000000004011ce &lt;+58&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x00000000004011d3 &lt;+63&gt;:    pop    %rbx
0x00000000004011d4 &lt;+64&gt;:    retq   
</code></pre><p>这题要我们输入一个长度为6的字符串。之后，取出字符串中的每一个数，将它与0xf按位与得到ecx，再通过<code>edx = edx + *(4*ecx + 0x402720)</code>来获得edx，最后六个数算完等于0x2b就可以。因为作为字符输入的数字和0xf按位与后正好等于ascii码中的数字，所以只需要取该数字即可。我算出数字的对应关系是：0-0x2 1-0xa 2-0x6 3-0x1 4-0xc 5-0x10 6-0x9 7-0x3 8-0x4 9-0x7.所以取六个数，就可以取911108，算出来正好是0x2b。</p>
<h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><pre><code>0x00000000004011d5 &lt;+0&gt;:    push   %r14
0x00000000004011d7 &lt;+2&gt;:    push   %r13
0x00000000004011d9 &lt;+4&gt;:    push   %r12
0x00000000004011db &lt;+6&gt;:    push   %rbp
0x00000000004011dc &lt;+7&gt;:    push   %rbx
0x00000000004011dd &lt;+8&gt;:    sub    $0x50,%rsp
0x00000000004011e1 &lt;+12&gt;:    mov    %rsp,%r13
0x00000000004011e4 &lt;+15&gt;:    mov    %rsp,%rsi
0x00000000004011e7 &lt;+18&gt;:    callq  0x4016de &lt;read_six_numbers&gt;
0x00000000004011ec &lt;+23&gt;:    mov    %rsp,%r14
0x00000000004011ef &lt;+26&gt;:    mov    $0x0,%r12d
0x00000000004011f5 &lt;+32&gt;:    mov    %r13,%rbp
0x00000000004011f8 &lt;+35&gt;:    mov    0x0(%r13),%eax
0x00000000004011fc &lt;+39&gt;:    sub    $0x1,%eax
0x00000000004011ff &lt;+42&gt;:    cmp    $0x5,%eax
0x0000000000401202 &lt;+45&gt;:    jbe    0x401209 &lt;phase_6+52&gt;
0x0000000000401204 &lt;+47&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x0000000000401209 &lt;+52&gt;:    add    $0x1,%r12d
0x000000000040120d &lt;+56&gt;:    cmp    $0x6,%r12d
0x0000000000401211 &lt;+60&gt;:    je     0x401234 &lt;phase_6+95&gt;
0x0000000000401213 &lt;+62&gt;:    mov    %r12d,%ebx
0x0000000000401216 &lt;+65&gt;:    movslq %ebx,%rax
0x0000000000401219 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax
0x000000000040121c &lt;+71&gt;:    cmp    %eax,0x0(%rbp)
0x000000000040121f &lt;+74&gt;:    jne    0x401226 &lt;phase_6+81&gt;
0x0000000000401221 &lt;+76&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x0000000000401226 &lt;+81&gt;:    add    $0x1,%ebx
0x0000000000401229 &lt;+84&gt;:    cmp    $0x5,%ebx
0x000000000040122c &lt;+87&gt;:    jle    0x401216 &lt;phase_6+65&gt;
0x000000000040122e &lt;+89&gt;:    add    $0x4,%r13
0x0000000000401232 &lt;+93&gt;:    jmp    0x4011f5 &lt;phase_6+32&gt;
0x0000000000401234 &lt;+95&gt;:    lea    0x18(%rsp),%rsi
0x0000000000401239 &lt;+100&gt;:    mov    %r14,%rax
0x000000000040123c &lt;+103&gt;:    mov    $0x7,%ecx
0x0000000000401241 &lt;+108&gt;:    mov    %ecx,%edx
0x0000000000401243 &lt;+110&gt;:    sub    (%rax),%edx
0x0000000000401245 &lt;+112&gt;:    mov    %edx,(%rax)
0x0000000000401247 &lt;+114&gt;:    add    $0x4,%rax
0x000000000040124b &lt;+118&gt;:    cmp    %rsi,%rax
0x000000000040124e &lt;+121&gt;:    jne    0x401241 &lt;phase_6+108&gt;
0x0000000000401250 &lt;+123&gt;:    mov    $0x0,%esi
0x0000000000401255 &lt;+128&gt;:    jmp    0x401278 &lt;phase_6+163&gt;
0x0000000000401257 &lt;+130&gt;:    mov    0x8(%rdx),%rdx
0x000000000040125b &lt;+134&gt;:    add    $0x1,%eax
0x000000000040125e &lt;+137&gt;:    cmp    %ecx,%eax
0x0000000000401260 &lt;+139&gt;:    jne    0x401257 &lt;phase_6+130&gt;
0x0000000000401262 &lt;+141&gt;:    jmp    0x401269 &lt;phase_6+148&gt;
0x0000000000401264 &lt;+143&gt;:    mov    $0x604300,%edx
0x0000000000401269 &lt;+148&gt;:    mov    %rdx,0x20(%rsp,%rsi,2)
0x000000000040126e &lt;+153&gt;:    add    $0x4,%rsi
0x0000000000401272 &lt;+157&gt;:    cmp    $0x18,%rsi
0x0000000000401276 &lt;+161&gt;:    je     0x40128c &lt;phase_6+183&gt;
0x0000000000401278 &lt;+163&gt;:    mov    (%rsp,%rsi,1),%ecx
0x000000000040127b &lt;+166&gt;:    cmp    $0x1,%ecx
0x000000000040127e &lt;+169&gt;:    jle    0x401264 &lt;phase_6+143&gt;
0x0000000000401280 &lt;+171&gt;:    mov    $0x1,%eax
0x0000000000401285 &lt;+176&gt;:    mov    $0x604300,%edx
0x000000000040128a &lt;+181&gt;:    jmp    0x401257 &lt;phase_6+130&gt;
0x000000000040128c &lt;+183&gt;:    mov    0x20(%rsp),%rbx
0x0000000000401291 &lt;+188&gt;:    lea    0x28(%rsp),%rax
0x0000000000401296 &lt;+193&gt;:    lea    0x50(%rsp),%rsi
0x000000000040129b &lt;+198&gt;:    mov    %rbx,%rcx
0x000000000040129e &lt;+201&gt;:    mov    (%rax),%rdx
0x00000000004012a1 &lt;+204&gt;:    mov    %rdx,0x8(%rcx)
0x00000000004012a5 &lt;+208&gt;:    add    $0x8,%rax
0x00000000004012a9 &lt;+212&gt;:    cmp    %rsi,%rax
0x00000000004012ac &lt;+215&gt;:    je     0x4012b3 &lt;phase_6+222&gt;
0x00000000004012ae &lt;+217&gt;:    mov    %rdx,%rcx
0x00000000004012b1 &lt;+220&gt;:    jmp    0x40129e &lt;phase_6+201&gt;
0x00000000004012b3 &lt;+222&gt;:    movq   $0x0,0x8(%rdx)
0x00000000004012bb &lt;+230&gt;:    mov    $0x5,%ebp
0x00000000004012c0 &lt;+235&gt;:    mov    0x8(%rbx),%rax
0x00000000004012c4 &lt;+239&gt;:    mov    (%rax),%eax
0x00000000004012c6 &lt;+241&gt;:    cmp    %eax,(%rbx)
0x00000000004012c8 &lt;+243&gt;:    jge    0x4012cf &lt;phase_6+250&gt;
0x00000000004012ca &lt;+245&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x00000000004012cf &lt;+250&gt;:    mov    0x8(%rbx),%rbx
0x00000000004012d3 &lt;+254&gt;:    sub    $0x1,%ebp
0x00000000004012d6 &lt;+257&gt;:    jne    0x4012c0 &lt;phase_6+235&gt;
0x00000000004012d8 &lt;+259&gt;:    add    $0x50,%rsp
0x00000000004012dc &lt;+263&gt;:    pop    %rbx
0x00000000004012dd &lt;+264&gt;:    pop    %rbp
0x00000000004012de &lt;+265&gt;:    pop    %r12
0x00000000004012e0 &lt;+267&gt;:    pop    %r13
0x00000000004012e2 &lt;+269&gt;:    pop    %r14
0x00000000004012e4 &lt;+271&gt;:    retq   
</code></pre><p>第六题又是输入六个数。它有许多个分支和循环，按先后顺序来限制了这六个数的大小和相互关系。第一个分支，保证了所有的输入都在1-6之间。第二个分支，保证了这六个输入没有重复。第三个分支，将这六个数重新置为7-x。第四个分支，按照输入数值i的大小，依次把<code>0x604300+(i-1)*0x10</code>放到<code>rsp+0x20+2*i*0x4</code>中，然后比较它们对应内存数字的大小，必须是递减的顺序。根据地址所对应的值递减的规律，有4&gt;1&gt;3&gt;2&gt;5&gt;0。由于上文对每个数减一再倒置，所以事实上应该是2&gt;5&gt;3&gt;4&gt;1&gt;6。</p>
<p>所以本题答案是2 5 3 4 1 6。</p>
<h3 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h3><p>secret_phase需要在phase_refused处设置断点强制进入。</p>
<pre><code>0x0000000000401323 &lt;+0&gt;:     push   %rbx
0x0000000000401324 &lt;+1&gt;:     callq  0x401721 &lt;read_line&gt;
0x0000000000401329 &lt;+6&gt;:     mov    $0xa,%edx
0x000000000040132e &lt;+11&gt;:    mov    $0x0,%esi
0x0000000000401333 &lt;+16&gt;:    mov    %rax,%rdi
0x0000000000401336 &lt;+19&gt;:    callq  0x400c50 &lt;strtol@plt&gt;
0x000000000040133b &lt;+24&gt;:    mov    %rax,%rbx
0x000000000040133e &lt;+27&gt;:    lea    -0x1(%rax),%eax
0x0000000000401341 &lt;+30&gt;:    cmp    $0x3e8,%eax
0x0000000000401346 &lt;+35&gt;:    jbe    0x40134d &lt;secret_phase+42&gt;
0x0000000000401348 &lt;+37&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x000000000040134d &lt;+42&gt;:    mov    %ebx,%esi
0x000000000040134f &lt;+44&gt;:    mov    $0x604120,%edi
0x0000000000401354 &lt;+49&gt;:    callq  0x4012e5 &lt;fun7&gt;
0x0000000000401359 &lt;+54&gt;:    cmp    $0x3,%eax
0x000000000040135c &lt;+57&gt;:    je     0x401363 &lt;secret_phase+64&gt;
0x000000000040135e &lt;+59&gt;:    callq  0x4016a8 &lt;explode_bomb&gt;
0x0000000000401363 &lt;+64&gt;:    mov    $0x4026b0,%edi
0x0000000000401368 &lt;+69&gt;:    callq  0x400b80 &lt;puts@plt&gt;
0x000000000040136d &lt;+74&gt;:    callq  0x401847 &lt;phase_defused&gt;
0x0000000000401372 &lt;+79&gt;:    pop    %rbx
0x0000000000401373 &lt;+80&gt;:    retq   
</code></pre><p>先读入一行，转为长整型。并且这个数不能大于0x3e8。然后将这个数和地址0x604120作为参数传入func7，如果得到eax的值为3，就成功破解了炸弹。</p>
<p>下面来看func7</p>
<pre><code>0x00000000004012e5 &lt;+0&gt;:    sub    $0x8,%rsp
0x00000000004012e9 &lt;+4&gt;:    test   %rdi,%rdi
0x00000000004012ec &lt;+7&gt;:    je     0x401319 &lt;fun7+52&gt;
0x00000000004012ee &lt;+9&gt;:    mov    (%rdi),%edx
0x00000000004012f0 &lt;+11&gt;:    cmp    %esi,%edx
0x00000000004012f2 &lt;+13&gt;:    jle    0x401301 &lt;fun7+28&gt;
0x00000000004012f4 &lt;+15&gt;:    mov    0x8(%rdi),%rdi
0x00000000004012f8 &lt;+19&gt;:    callq  0x4012e5 &lt;fun7&gt;
0x00000000004012fd &lt;+24&gt;:    add    %eax,%eax
0x00000000004012ff &lt;+26&gt;:    jmp    0x40131e &lt;fun7+57&gt;
0x0000000000401301 &lt;+28&gt;:    mov    $0x0,%eax
0x0000000000401306 &lt;+33&gt;:    cmp    %esi,%edx
0x0000000000401308 &lt;+35&gt;:    je     0x40131e &lt;fun7+57&gt;
0x000000000040130a &lt;+37&gt;:    mov    0x10(%rdi),%rdi
0x000000000040130e &lt;+41&gt;:    callq  0x4012e5 &lt;fun7&gt;
0x0000000000401313 &lt;+46&gt;:    lea    0x1(%rax,%rax,1),%eax
0x0000000000401317 &lt;+50&gt;:    jmp    0x40131e &lt;fun7+57&gt;
0x0000000000401319 &lt;+52&gt;:    mov    $0xffffffff,%eax
0x000000000040131e &lt;+57&gt;:    add    $0x8,%rsp
0x0000000000401322 &lt;+61&gt;:    retq   
</code></pre><p>fun7是一个递归函数，如果第一个参数不为0，就和第二个参数比较，进行递归。我进行递归到第三层时，得到eax最终为3。而输入为107时，递归正好能进行3层，所以本题的输入就为107。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次实验其实就是让我们对课上学习的汇编代码进行熟悉，比如堆栈的使用，函数的传参。一共有六个关卡和一个隐藏关卡，每一个关卡都需要我们进行一行输入，如果输入的数字或者字符串满足一定的要求，就能跳过<code>callq  0x4016a8 &lt;explode_bomb&gt;</code>这一个导致“炸弹爆炸”的调用，进行下一个阶段。当六个阶段解决完毕后，该题目通过。此外还有一个隐藏关，需要显式调用<code>call 0x401323 &lt;secret_phase&gt;</code>来完成。</p>]]>
    
    </summary>
    
      <category term="assembly" scheme="https://sunlightsgy.github.io/tags/assembly/"/>
    
      <category term="courses" scheme="https://sunlightsgy.github.io/categories/courses/"/>
    
  </entry>
  
</feed>
